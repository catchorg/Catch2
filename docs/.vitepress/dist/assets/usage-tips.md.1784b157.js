import{_ as e,c as s,o as a,a as n}from"./app.f3758f8e.js";const m=JSON.parse('{"title":"Best practices and other tips on using Catch2","description":"","frontmatter":{},"headers":[{"level":2,"title":"Running tests","slug":"running-tests"},{"level":2,"title":"Running tests in parallel","slug":"running-tests-in-parallel"},{"level":2,"title":"Organizing tests into binaries","slug":"organizing-tests-into-binaries"}],"relativePath":"usage-tips.md","lastUpdated":1656062422000}'),t={name:"usage-tips.md"},r=n(`<p><a id="top"></a></p><h1 id="best-practices-and-other-tips-on-using-catch2" tabindex="-1">Best practices and other tips on using Catch2 <a class="header-anchor" href="#best-practices-and-other-tips-on-using-catch2" aria-hidden="true">#</a></h1><h2 id="running-tests" tabindex="-1">Running tests <a class="header-anchor" href="#running-tests" aria-hidden="true">#</a></h2><p>Your tests should be run in a manner roughly equivalent with:</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">./tests --order rand --warn NoAssertions</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Notice that all the tests are run in a large batch, their relative order is randomized, and that you ask Catch2 to fail test whose leaf-path does not contain an assertion.</p><p>The reason I recommend running all your tests in the same process is that this exposes your tests to interference from their runs. This can be both positive interference, where the changes in global state from previous test allow later tests to pass, but also negative interference, where changes in global state from previous test causes later tests to fail.</p><p>In my experience, interference, especially destructive interference, usually comes from errors in the code under test, rather than the tests themselves. This means that by allowing interference to happen, our tests can find these issues. Obviously, to shake out interference coming from different orderings of tests, the test order also need to be shuffled between runs.</p><p>However, running all tests in a single batch eventually becomes impractical as they will take too long to run, and you will want to run your tests in parallel.</p><p><a id="parallel-tests"></a></p><h2 id="running-tests-in-parallel" tabindex="-1">Running tests in parallel <a class="header-anchor" href="#running-tests-in-parallel" aria-hidden="true">#</a></h2><p>There are multiple ways of running tests in parallel, with various level of structure. If you are using CMake and CTest, then we provide a helper function <a href="./cmake-integration.html#automatic-test-registration"><code>catch_discover_tests</code></a> that registers each Catch2 <code>TEST_CASE</code> as a single CTest test, which is then run in a separate process. This is an easy way to set up parallel tests if you are already using CMake &amp; CTest to run your tests, but you will lose the advantage of running tests in batches.</p><p>Catch2 also supports <a href="./command-line.html#test-sharding">splitting tests in a binary into multiple shards</a>. This can be used by any test runner to run batches of tests in parallel. Do note that when selecting on the number of shards, you should have more shards than there are cores, to avoid issues with long running tests getting accidentally grouped in the same shard, and causing long-tailed execution time.</p><p><strong>Note that naively composing sharding and random ordering of tests will break.</strong></p><p>Invoking Catch2 test executable like this</p><div class="language-text line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 0 --shard-count 3</span></span>
<span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 1 --shard-count 3</span></span>
<span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 2 --shard-count 3</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>does not guarantee covering all tests inside the executable, because each invocation will have its own random seed, thus it will have its own random order of tests and thus the partitioning of tests into shards will be different as well.</p><p>To do this properly, you need the individual shards to share the random seed, e.g.</p><div class="language-text line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 0 --shard-count 3 --rng-seed 0xBEEF</span></span>
<span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 1 --shard-count 3 --rng-seed 0xBEEF</span></span>
<span class="line"><span style="color:#A6ACCD;">./tests --order rand --shard-index 2 --shard-count 3 --rng-seed 0xBEEF</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="organizing-tests-into-binaries" tabindex="-1">Organizing tests into binaries <a class="header-anchor" href="#organizing-tests-into-binaries" aria-hidden="true">#</a></h2><p>Both overly large and overly small test binaries can cause issues. Overly large test binaries have to be recompiled and relinked often, and the link times are usually also long. Overly small test binaries in turn pay significant overhead from linking against Catch2 more often per compiled test case, and also make it hard/impossible to run tests in batches.</p><p>Because there is no hard and fast rule for the right size of a test binary, I recommend having 1:1 correspondence between libraries in project and test binaries. (At least if it is possible, in some cases it is not.) Having a test binary for each library in project keeps related tests together, and makes tests easy to navigate by reflecting the project&#39;s organizational structure.</p><hr><p><a href="./Readme.html#top">Home</a></p>`,24),i=[r];function o(l,p,c,d,h,u){return a(),s("div",null,i)}var b=e(t,[["render",o]]);export{m as __pageData,b as default};
